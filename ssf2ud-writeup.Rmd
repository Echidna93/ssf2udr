---
title: "ssf2ud-writeup"
author: "alex jack"
date: "2025-01-14"
output:
  pdf_document: default
  word_document:
    reference_docx: doc_style.docx
bibliography: SSF2UD.json
csl: ecology.csl
---
```{r load packages, echo = FALSE, warning=FALSE}
library(doParallel) # for running foreach in parallel
```

```{r constants, echo = FALSE}
# CONSTANTS -------------------------------------------------------
n_rows<- 100
n_cols <- 100
isDiscrete <- FALSE
source('helpers.R')
nburnin <- 5000
nsteps <- 10000
sf <- 6 # radius of circular smoothing window
trajID <- 1 # tracks the trajectory number 
# set up file directory
path <- "./data/output" # main file path
# make the domain dir
domName <- paste("domain", n_cols, "by", n_cols, sep = "-")
if(!dir.exists(paste0(path, "/",domName))){
  dir.create(paste0(path, "/", domName)) # create dir
}
path <- paste0(path, "/", domName)
# create and register worker nodes
n_cores <- parallel::detectCores()

# Optionally leave 1 core free for the OS
n_workers <- max(1, n_cores - 4)
#n_workers <- 2
# Set up the cluster
cl <- makeCluster(n_workers)

registerDoParallel(cl)
```
```{r generate UD stats, echo = FALSE, eval = FALSE}
# generate unique theta-rho combinations
thetas <- c(-0.5, -0.25, -0.1, -0.05, 0,
       0.05, 0.1, 0.15, 0.2, 1.0, 1.5)
rhos <- c(0,2,4,6,40)
controls <- data.frame(expand.grid(thetas, rhos))
names(controls) <- c("theta", "rho")
#controls[nrow(controls) + 1,] <- c(0, 0)
#controls <- controls %>% arrange(theta)tra
library(data.table)
#controls <- data.frame(theta = c(4,4), rho = c(6,4))
names(controls) <- c("theta", "rho")
foreach(i = seq_len(nrow(controls)),
        .packages = c("terra", "data.table")) %dopar% {
  neighOffsets <- data.frame(
  dx = c(0, 0, 0, -1, 1),
  dy = c(-1, 1, 0, 0, 0))
  buffCount <- 0
  n_rows<- 10
  n_cols <- 10
  buffSize <- 10
  trajBuff <- list()
  trajID <- 1
  ud <- matrix(0, nrow = n_rows, ncol = n_cols)
  resultList <- list()
  theta <- as.numeric(controls[i,"theta"])
  rho <- as.numeric(controls[i,"rho"])
  land <- makeLandscapeMatrix(nrow = n_rows, ncol = n_cols, seed = i)
  #land <- rast(paste0(path, "/", "test-4-0", "/", "ls.tif"))
  #land <- matrix(values(land), nrow = n_rows, ncol = n_cols)
  land <- iterativeSmooth(land, sf, rho, n_rows, n_cols)
    id <- paste0("test", "-", theta, "-", rho)
  if(isDiscrete){
    land <- ifelse(land >= 0.5, 1, 0)
    id <- paste0(id, "-d")
  }
  #id <- paste0("test", "-", theta, "-", rho)
  burninCounter <- 1
  if(!dir.exists(paste0(path, "/",domName))){
    dir.create(paste0(path, "/", id)) # create dir
  }
  #write landscape to file
  writeRaster(rast(land), filename = paste0(path,"/", id, "/", "ls.tif"), overwrite = TRUE)
  for(j in seq_len(n_rows)){
    for(k in seq_len(n_cols)){
      trajList <- list()
    xProj <- k
    yProj <- j
    xReal <- k
    yReal <- j
    # # get init location
    rowResult <- data.table::data.table(trajID = trajID,
                              x.proj = k,
                              y.proj = j,
                              x.real = k,
                              y.real = j)
    for(iter in seq_len(nsteps)){
      neighProjX <- clampToSize(xProj + neighOffsets$dx, ncol = n_cols)
      neighProjY <- clampToSize(yProj + neighOffsets$dy, ncol = n_cols)
      neighRealX <- xReal + neighOffsets$dx
      neighRealY <- yReal + neighOffsets$dy
      landVals <- land[cbind(neighProjY, neighProjX)]
  
      wghts <- exp(theta * landVals)
      #if (any(is.na(wghts)) || sum(wghts) == 0) next  # <-- ADD THIS LINE
      decision <- sample(1:length(neighProjX), 1, prob = wghts, replace = TRUE)
      
      rowResult <- data.table(trajID = trajID,
                              x.proj = neighProjX[decision],
                              y.proj = neighProjY[decision],
                              x.real = neighRealX[decision],
                              y.real = neighRealY[decision])
  
      if (iter > nburnin) {
      trajList[[length(trajList) + 1]] <- rowResult
      #print(trajList)
      ud[cbind(rowResult$y.proj, rowResult$x.proj)] <- ud[cbind(rowResult$y.proj, rowResult$x.proj)] + 1
      }
      # update x and y coords
      xProj <- neighProjX[decision]
      yProj <- neighProjY[decision]
      xReal <- neighRealX[decision]
      yReal <- neighRealY[decision]
      }
    trajBuff[[length(trajBuff) + 1]] <- rbindlist(trajList)
    buffCount <- buffCount + 1
    print(buffCount)
    trajID <- trajID + 1
    # flush
    if (buffCount >= buffSize) {
      fwrite(rbindlist(trajBuff), file = paste0(path,"/", id,"/", "traj"), sep = ",", append = TRUE,
      col.names = !file.exists(paste0(path,"/", id,"/", "traj")))
      trajBuff <- list()
      buffCount <- 0
    }
    
    }
  }
   writeRaster(rast(ud), filename = paste0(path,"/", id, "/", "ud.tif"), overwrite = TRUE)
   # final flush
   if (length(trajBuff) > 0) {
      fwrite(rbindlist(trajBuff), file = paste0(path,"/", id,"/", "traj"), sep = ",", append = TRUE,
      col.names = !file.exists(paste0(path,"/", id,"/", "traj")))
    }
}
```

```{r sim direction persistence, echo = FALSE, eval = FALSE}
# generate unique theta-rho combinations
thetas <- c(0.5, 1, 1.5, 2)
rhos <- c(0,2,6,40)
kappa <- 2.5
distBeta <- -1
controls <- data.frame(expand.grid(thetas, rhos))
names(controls) <- c("theta", "rho")
#controls[nrow(controls) + 1,] <- c(0, 0)
#controls <- controls %>% arrange(theta)tra
library(data.table)
#controls <- data.frame(theta = c(4,4), rho = c(6,4))
names(controls) <- c("theta", "rho")
foreach(i = seq_len(nrow(controls)),
        .packages = c("terra", "data.table")) %dopar% {
  neighOffsets <- data.frame(
  dx = c(0, 0, -1, 1, 1, -1, 1, -1),
  dy = c(-1, 1, 0, 0, -1, -1, 1, 1))
  step_cost <- sqrt(neighOffsets$dx^2 + neighOffsets$dy^2)
  buffCount <- 0
  n_rows<- 100
  n_cols <- 100
  buffSize <- 10
  trajBuff <- list()
  trajID <- 1
  ud <- matrix(0, nrow = n_rows, ncol = n_cols)
  resultList <- list()
  theta <- as.numeric(controls[i,"theta"])
  rho <- as.numeric(controls[i,"rho"])
  land <- makeLandscapeMatrix(nrow = n_rows, ncol = n_cols, seed = i)
  #land <- rast(paste0(path, "/", "test-4-0", "/", "ls.tif"))
  #land <- matrix(values(land), nrow = n_rows, ncol = n_cols)
  land <- iterativeSmooth(land, sf, rho, n_rows, n_cols)
    id <- paste0("test", "-", theta, "-", rho, "-", kappa)
  if(isDiscrete){
    land <- ifelse(land >= 0.5, 1, 0)
    id <- paste0(id, "-d")
  }
  #id <- paste0("test", "-", theta, "-", rho)
  burninCounter <- 1
  if(!dir.exists(paste0(path, "/",domName))){
    dir.create(paste0(path, "/", id)) # create dir
  }
  #write landscape to file
  writeRaster(rast(land), filename = paste0(path,"/", id, "/", "ls.tif"), overwrite = TRUE)
  for(j in seq_len(n_rows)){
    for(k in seq_len(n_cols)){
        prev_dx <- 0
        prev_dy <- 0
        trajList <- list()
        xProj <- k
        yProj <- j
        xReal <- k
        yReal <- j
        # # get init location
        rowResult <- data.table::data.table(trajID = trajID,
                              x.proj = k,
                              y.proj = j,
                              x.real = k,
                              y.real = j)
        for(iter in seq_len(nsteps)){
      
  # Compute dot product between previous direction and each candidate
        dot_products <- prev_dx * neighOffsets$dx + prev_dy * neighOffsets$dy

  # Get vector norms
  prev_norm <- sqrt(prev_dx^2 + prev_dy^2)
  cand_norms <- sqrt(neighOffsets$dx^2 + neighOffsets$dy^2)

  cos_angles <- dot_products / (prev_norm * cand_norms)
  cos_angles[is.nan(cos_angles)] <- 0  # handle 0/0 for first step

  neighProjX <- clampToSize(xProj + neighOffsets$dx, ncol = n_cols)
  neighProjY <- clampToSize(yProj + neighOffsets$dy, ncol = n_cols)
  neighRealX <- xReal + neighOffsets$dx
  neighRealY <- yReal + neighOffsets$dy
  landVals <- land[cbind(neighProjY, neighProjX)]
  # Now compute weights
  combined_weights <- exp((theta * landVals) + (kappa * cos_angles) + distBeta*step_cost)

      #if (any(is.na(wghts)) || sum(wghts) == 0) next  # <-- ADD THIS LINE
  decision <- sample(1:length(neighProjX), 1, prob = combined_weights, replace = TRUE)
  prev_dx <- neighOffsets[decision,]$dx
  prev_dy <- neighOffsets[decision,]$dy
  rowResult <- data.table(trajID = trajID,
                              x.proj = neighProjX[decision],
                              y.proj = neighProjY[decision],
                              x.real = neighRealX[decision],
                              y.real = neighRealY[decision])
  
      if (iter > nburnin) {
      trajList[[length(trajList) + 1]] <- rowResult
      #print(trajList)
      ud[cbind(rowResult$y.proj, rowResult$x.proj)] <- ud[cbind(rowResult$y.proj, rowResult$x.proj)] + 1
      }
      # update x and y coords
      xProj <- neighProjX[decision]
      yProj <- neighProjY[decision]
      xReal <- neighRealX[decision]
      yReal <- neighRealY[decision]
      }
    trajBuff[[length(trajBuff) + 1]] <- rbindlist(trajList)
    buffCount <- buffCount + 1
    print(buffCount)
    trajID <- trajID + 1
    # flush
    if (buffCount >= buffSize) {
      fwrite(rbindlist(trajBuff), file = paste0(path,"/", id,"/", "traj"), sep = ",", append = TRUE,
      col.names = !file.exists(paste0(path,"/", id,"/", "traj")))
      trajBuff <- list()
      buffCount <- 0
    }
    
    }
  }
   writeRaster(rast(ud), filename = paste0(path,"/", id, "/", "ud.tif"), overwrite = TRUE)
   # final flush
   if (length(trajBuff) > 0) {
      fwrite(rbindlist(trajBuff), file = paste0(path,"/", id,"/", "traj"), sep = ",", append = TRUE,
      col.names = !file.exists(paste0(path,"/", id,"/", "traj")))
    }
}
```


## Introduction
# version 1

Ecology is fundamentally the study of the factors which drive the arrangement of organisms over space and time @eltonAnimalEcology1927. Thus, ecologists have concocted numerous methods of quantifying and approximating this. One of the most popular concepts of animal space use or arrangement is that of a home range which is the area to which an organism restricts it's movements to carry out normal functioning @burtTerritorialityHomeRange1943.

The utilization distribution (or home range; UD) is the probabilistic formulation of the home range concept and thus is of great importance in the field of ecology. This quantity describes the probability that a given individual will be detected in a given location  @winkleComparisonSeveralProbabilistic1975. It has been utilized to help address conservation issues ranging from wildlife disease @jennelleMovementWhitetailedDeer2022a to energy development @cervantesUtilizationDistributionGlobal2023. Utilization distributions can be broken up into two fundamental classes those that are used to describe observed patterns (occurence) and those used to predict (range; @horneAnimalHomeRanges2020).

To date quantifying a UD is mired by challenges that make them mathematically intractable for most practitioners, computationally expensive, or unreliable. For instance UDs can be readily quantified from systems of differential equations @barnettAnalyticSteadystateSpace2008a. However, these methodologies are not a tractable solution for many ecologists and practitioners. Alternatively quantifying a UD might also involve computationally demanding simulations which take long periods of time to reach ergodicity. Another alternative to scale up utilization distributions from Resource Selection Functions (RSAs). Another alternative is to simply estimate the UD utilizing a probabilistic or geometric approach @fiebergCouldYouPlease2012.

The purpose of this paper is to identify a method for scaling up movement processes to describe patterns of space-use. First we present a method for scaling up movement parameters which can be readily ascertained from spatial and movement packages in program-R.

# version 2


## Methods
We examined relationships between movement, habitat selection and landscape configuration by simulating telemetry data for an agent across a `r I(nrow)` by `r I(n_cols)` domain of continuous habitat (ranging from 0 to 1; Figure 1). To test the relationships between these variables we stochastically changed variables controlling autocorrelation, agent habitat preference, thinning period (i.e., the number of samples that we threw out at the end of each simulation), and landscape autocorrelation.

### Movement 
For a given cell, $c$, the agent was programmed only to move to rook cells (i.e., the set of neighboring cells $c_n$ that shared more than one point with cell $c$) within one cell of $c$ or stay in the same cell. The likelihood of the agent moving from a cell $c$ to any of it's neighbors or to stay in the same cell is given by Equation 1. 

$$
p(c_{n}) \ = \ e^{-p + \theta(c_n)} \ (1)
$$
Equation 1 gives the transition probability between the cell $c$ and a neighboring cell $c_n$ given by the exponential of the sum of the movement penalty $p$ (n.b., for the case of staying in the same cell $p = 0$) and the preference of the agent $\theta$ for the neighboring cell $c_n$. The values $p$ and $\theta$ were scholastically updated throughout the simulation to examine relationships between movement penalty ($p$), and preference $\theta$.

Since we wanted to simulate movement on a torus we utilized a mixture modular arithmetic and subtraction to ensure that if the agent left the original `r I(nrow)` by `r I(n_cols)` domain that it ended it's step back inside the domain. For example if the agent started at position [1,1] we would add or subtract the size of the domain (depending upon whether the step was smaller or larger than allowed within the domain) to project the agent back in (Figure 3). However we did track the original real steps taken by the agent (Figure 4) in addition to the projected steps.


### Landscape autocorrelation
To smooth the landscape we padded the `r I(nrow)` by `r I(n_cols)` domain with cells side from the opposite side of the domain. The number of cells that we padded on each side correlated to the smoothing factor used. For example, for a smoothing factor of 3 we took 6 rows or columns from the opposite side and attached them to the domain. We then utilized the smoothing function *focal* from the R-package *terra* to take the average of the cells within a square moving window with size of the smoothing factor @hijmans_terraSpatialData2024. These cells were then averaged over a square with of size 3 (i.e., an area of 9 $units^2$). After smoothing the domain was cropped back to it's original size by removing the padded cells. Once the landscape was smoothed and cropped the resultant domain was then range normalized to ensure that the only the arrangement and not the intensity of the values changed between smoothed landscapes.

### Thinning period
To examine how our thinning period changed the we chose between a number of different thinning values ranging from 100 to 250. That is, for a thinning value of 100 we would throw out all but every 100^{th} step likewise for a thinning value of 250 we would throw out all but every 250^{th} step.

### Modelling
To retrieve the downstream selection coefficient ($\beta$) for a given habitat type $t$ the function $fit_issf$ from the R-package AMT @signerAnimalMovementTools2019. The equation to retrieve the downstream $\beta$ was a linear combination of the step length, the $log$ of the step length, and the habitat value associated with the cell at the end of the step.

Coefficients were then taken from the fit model and new datasets were generated using the function $mvnorm$ from the R-packages MASS @venablesModernAppliedStatistics2002. These new $beta$ values were then used to generate new shape and scale parameters from AMT using the function $update_sl_distr$.

Once the full UD was acquired we also fit a simple RSF to the used versus available points. We did this by assigning used cells a value of one and then binding them to all the cells in the domain and assigning them a value of zero. We then regressed these assigned binary values against the actual cell values to estimate our RSF.

## RESULTS

## CONCLUSIONS


![Figure 1. An image of an unsmoothed `r I(nrow)` by `r I(n_cols)` domain.](./data/output/figures/land.png)

![Figure 2. An image of a `r I(nrow)` by `r I(n_cols)` domain smoothed by a factor of 3.](./data/output/figures/land_smooth.png)

![Figure 3. An image of an `r I(nrow)` by `r I(n_cols)` domain with possible steps (red) the agent could take from the first cell (blue).](./data/output/figures/land-possible-steps.png)

![Figure 4. An image of an `r I(nrow)` by `r I(n_cols)` domain with witha  smoothing factor of 3. A trajectory (outlined in red) is shown that extended beyond the original domain.](./data/movement-extended-land.png)